import { __awaiter } from "tslib";
import { Injectable } from '@angular/core';
import { Subject } from 'rxjs';
import { defer, from, throwError } from 'rxjs';
import { share, catchError } from 'rxjs/operators';
import { errorMessages } from '../../constants/error-messages.constant';
import { isHttpResponse } from '../../helpers/is-http-response.helper';
import { convertBlobToBase64 } from '../../helpers/convert-blob-to-base64.helper';
import { decodeRawData } from '../../helpers/decode-raw-data.helper';
import * as i0 from "@angular/core";
import * as i1 from "../cache-storage/cache-storage.service";
export class CacheService {
    constructor(cacheStorage) {
        this.cacheStorage = cacheStorage;
        this.ttl = 60 * 60; // one hour
        this.cacheEnabled = true;
        this.invalidateOffline = false;
        this.loadCache();
    }
    /**
     * Disable or enable cache.
     */
    enableCache(enable = true) {
        this.cacheEnabled = enable;
    }
    /**
     * Set if expired cache should be invalidated if device is offline.
     */
    setOfflineInvalidate(offlineInvalidate) {
        this.invalidateOffline = !offlineInvalidate;
    }
    /**
     * Set default TTL.
     * @param ttl TTL in seconds.
     */
    setDefaultTTL(ttl) {
        return (this.ttl = ttl);
    }
    /**
     * Checks if the device is online.
     */
    isOnline() {
        return navigator.onLine;
    }
    /**
     * Saves an item to the cache storage with the provided options.
     * @param key The unique key
     * @param data The data to store
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns The saved data
     */
    saveItem(key, data, groupKey = 'none', ttl = this.ttl) {
        if (!this.cacheEnabled) {
            throw new Error(errorMessages.notEnabled);
        }
        if (Blob.name === data.constructor.name) {
            return this.saveBlobItem(key, data, groupKey, ttl);
        }
        const expires = new Date().getTime() + ttl * 1000;
        const type = isHttpResponse(data) ? 'response' : typeof data;
        const value = JSON.stringify(data);
        return this.cacheStorage.set(key, {
            value,
            expires,
            type,
            groupKey
        });
    }
    /**
     * Deletes an item from the cache storage.
     * @param key The unique key
     * @returns A promise which will resolve when the item is removed.
     */
    removeItem(key) {
        if (!this.cacheEnabled) {
            throw new Error(errorMessages.notEnabled);
        }
        return this.cacheStorage.remove(key);
    }
    /**
     * Removes all items with a key that matches pattern.
     * @returns A promise which will resolve when all the items are removed.
     */
    removeItems(pattern) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            const regex = new RegExp(`^${pattern.split('*').join('.*')}$`);
            const items = yield this.cacheStorage.all();
            return Promise.all(items
                .map((item) => item.key)
                .filter((key) => key && regex.test(key))
                .map((key) => this.removeItem(key)));
        });
    }
    /**
     * Gets item from cache without checking if it is expired.
     * @param key The unique key
     * @returns A promise which will resolve with the data from the cache.
     */
    getRawItem(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            try {
                const data = yield this.cacheStorage.get(key);
                if (!!data) {
                    return data;
                }
                throw new Error('');
            }
            catch (err) {
                throw new Error(errorMessages.notFound + key);
            }
        });
    }
    /**
     * Gets all items from the cache without checking if they are expired.
     * @returns A promise which will resove with all the items in the cache.
     */
    getRawItems() {
        return this.cacheStorage.all();
    }
    /**
     * Check sif item exists in cache regardless if expired or not.
     * @param key The unique key
     * @returns A boolean which will be true the key if exists.
     */
    itemExists(key) {
        if (!this.cacheEnabled) {
            throw new Error(errorMessages.notEnabled);
        }
        return this.cacheStorage.exists(key);
    }
    /**
     * Gets item from cache with expire check.
     * @param key The unique key
     * @returns The data from the cache
     */
    getItem(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            const data = yield this.getRawItem(key);
            if (data.expires < new Date().getTime() && (this.invalidateOffline || this.isOnline())) {
                throw new Error(errorMessages.expired + key);
            }
            return decodeRawData(data);
        });
    }
    /**
     * Gets or sets an item in the cache storage
     * @param key The unique key
     * @param factory The factory to update the value with if it's not present.
     * @param groupKey The group key
     * @param ttl The TTL in seconds.
     * @returns A promise which resolves with the data.
     */
    getOrSetItem(key, factory, groupKey, ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            let val;
            try {
                val = yield this.getItem(key);
            }
            catch (error) {
                val = yield factory();
                yield this.saveItem(key, val, groupKey, ttl);
            }
            return val;
        });
    }
    /**
     * Loads an item from the cache, if it's not there it will use the provided observable to set the value and return it.
     * @param key The unique key
     * @param observable The observable to provide the data if it's not present in the cache.
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns An observable with the data from the cache or provided observable.
     */
    loadFromObservable(key, observable, groupKey, ttl) {
        if (!this.cacheEnabled) {
            return observable;
        }
        observable = observable.pipe(share());
        return defer(() => {
            return from(this.getItem(key)).pipe(catchError((e) => {
                observable.subscribe((res) => {
                    return this.saveItem(key, res, groupKey, ttl);
                }, (error) => {
                    return throwError(error);
                });
                return observable;
            }));
        });
    }
    /**
     * Loads an item from cache regardless of expiry.
     * If the delay type is set to expired it will only get data from the observable when the item is expired.
     * If the delay type is set to all it will always get data from the observable.
     * @param key The unique key
     * @param observable The observable with data.
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @param delayType The delay type, defaults to expired.
     * @param metaKey The property on T to which to assign meta data.
     * @returns An observable which will emit the data.
     */
    loadFromDelayedObservable(key, observable, groupKey, ttl = this.ttl, delayType = 'expired', metaKey) {
        if (!this.cacheEnabled) {
            return observable;
        }
        const observableSubject = new Subject();
        observable = observable.pipe(share());
        const subscribeOrigin = () => {
            observable.subscribe((res) => {
                this.saveItem(key, res, groupKey, ttl);
                observableSubject.next(res);
                observableSubject.complete();
            }, (err) => {
                observableSubject.error(err);
            }, () => {
                observableSubject.complete();
            });
        };
        this.getItem(key)
            .then((data) => {
            if (metaKey) {
                data[metaKey] = data[metaKey] || {};
                data[metaKey].fromCache = true;
            }
            observableSubject.next(data);
            if (delayType === 'all') {
                subscribeOrigin();
            }
            else {
                observableSubject.complete();
            }
        })
            .catch((e) => {
            this.getRawItem(key)
                .then((res) => __awaiter(this, void 0, void 0, function* () {
                const result = yield decodeRawData(res);
                if (metaKey) {
                    result[metaKey] = result[metaKey] || {};
                    result[metaKey].fromCache = true;
                }
                observableSubject.next(result);
                subscribeOrigin();
            }))
                .catch(() => subscribeOrigin());
        });
        return observableSubject.asObservable();
    }
    /**
     * Perform complete cache clear
     * @returns A promise which resolves when the cache storage is cleared.
     */
    clearAll() {
        if (!this.cacheEnabled) {
            throw new Error(errorMessages.notEnabled);
        }
        return this.resetDatabase();
    }
    /**
     * Removes all expired items from the cache.
     * @param ignoreOnlineStatus Ignores the online status, defaults to false.
     * @returns A promise which resolves when all expired items are cleared from cache storage.
     */
    clearExpired(ignoreOnlineStatus = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            if (!this.isOnline() && !ignoreOnlineStatus) {
                throw new Error(errorMessages.browserOffline);
            }
            const items = yield this.cacheStorage.all();
            const datetime = new Date().getTime();
            return Promise.all(items.filter((item) => item.expires < datetime).map((item) => this.removeItem(item.key)));
        });
    }
    /**
     * Removes all item with specified group
     * @param groupKey The group key
     * @returns A promise which resolves when all the items in the group have been cleared.
     */
    clearGroup(groupKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            const items = yield this.cacheStorage.all();
            return Promise.all(items.filter((item) => item.groupKey === groupKey).map((item) => this.removeItem(item.key)));
        });
    }
    /**
     * Creates the cache storage.
     * If it fails it will provide and error message.
     */
    loadCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                return;
            }
            try {
                yield this.cacheStorage.create();
            }
            catch (error) {
                this.cacheEnabled = false;
                console.error(errorMessages.initialization, error);
            }
        });
    }
    /**
     * Resets the storage back to being empty.
     */
    resetDatabase() {
        return __awaiter(this, void 0, void 0, function* () {
            const items = yield this.cacheStorage.all();
            return Promise.all(items.map((item) => this.removeItem(item.key)));
        });
    }
    /**
     * Saves a blob item to the cache storage with the provided options.
     * @param key The unique key
     * @param blob The blob to store
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns The saved data
     */
    saveBlobItem(key, blob, groupKey = 'none', ttl = this.ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            const expires = new Date().getTime() + ttl * 1000;
            const type = blob.type;
            try {
                const base64data = yield convertBlobToBase64(blob);
                const value = JSON.stringify(base64data);
                return this.cacheStorage.set(key, {
                    value,
                    expires,
                    type,
                    groupKey
                });
            }
            catch (error) {
                throw new Error(error);
            }
        });
    }
}
CacheService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheService, deps: [{ token: i1.CacheStorageService }], target: i0.ɵɵFactoryTarget.Injectable });
CacheService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.CacheStorageService }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FjaGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2lvbmljLWNhY2hlL3NyYy9saWIvc2VydmljZXMvY2FjaGUvY2FjaGUuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQyxPQUFPLEVBQUUsS0FBSyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBR25ELE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSx5Q0FBeUMsQ0FBQztBQUN4RSxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sdUNBQXVDLENBQUM7QUFDdkUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFDbEYsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHNDQUFzQyxDQUFDOzs7QUFHckUsTUFBTSxPQUFPLFlBQVk7SUFLckIsWUFBb0IsWUFBaUM7UUFBakMsaUJBQVksR0FBWixZQUFZLENBQXFCO1FBSjdDLFFBQUcsR0FBVyxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQUMsV0FBVztRQUNsQyxpQkFBWSxHQUFZLElBQUksQ0FBQztRQUM3QixzQkFBaUIsR0FBWSxLQUFLLENBQUM7UUFHdkMsSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0lBQ3JCLENBQUM7SUFFRDs7T0FFRztJQUNJLFdBQVcsQ0FBQyxTQUFrQixJQUFJO1FBQ3JDLElBQUksQ0FBQyxZQUFZLEdBQUcsTUFBTSxDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRztJQUNJLG9CQUFvQixDQUFDLGlCQUEwQjtRQUNsRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcs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QUFJLENBQUMsSUFBSSxDQUFDO1lBRXZCLElBQUk7Z0JBQ0EsTUFBTSxVQUFVLEdBQUcsTUFBTSxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztnQkFDbkQsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFVLENBQUMsQ0FBQztnQkFFekMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7b0JBQzlCLEtBQUs7b0JBQ0wsT0FBTztvQkFDUCxJQUFJO29CQUNKLFFBQVE7aUJBQ1gsQ0FBQyxDQUFDO2FBQ047WUFBQyxPQUFPLEtBQUssRUFBRTtnQkFDWixNQUFNLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQzFCO1FBQ0wsQ0FBQztLQUFBOzt5R0E1WVEsWUFBWTs2R0FBWixZQUFZOzJGQUFaLFlBQVk7a0JBRHhCLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWZlciwgZnJvbSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc2hhcmUsIGNhdGNoRXJyb3IgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDYWNoZVN0b3JhZ2VTZXJ2aWNlIH0gZnJvbSAnLi4vY2FjaGUtc3RvcmFnZS9jYWNoZS1zdG9yYWdlLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3RvcmFnZUNhY2hlSXRlbSB9IGZyb20gJy4uLy4uL2ludGVyZmFjZXMvY2FjaGUtc3RvcmFnZS1pdGVtLmludGVyZmFjZSc7XG5pbXBvcnQgeyBlcnJvck1lc3NhZ2VzIH0gZnJvbSAnLi4vLi4vY29uc3RhbnRzL2Vycm9yLW1lc3NhZ2VzLmNvbnN0YW50JztcbmltcG9ydCB7IGlzSHR0cFJlc3BvbnNlIH0gZnJvbSAnLi4vLi4vaGVscGVycy9pcy1odHRwLXJlc3BvbnNlLmhlbHBlcic7XG5pbXBvcnQgeyBjb252ZXJ0QmxvYlRvQmFzZTY0IH0gZnJvbSAnLi4vLi4vaGVscGVycy9jb252ZXJ0LWJsb2ItdG8tYmFzZTY0LmhlbHBlcic7XG5pbXBvcnQgeyBkZWNvZGVSYXdEYXRhIH0gZnJvbSAnLi4vLi4vaGVscGVycy9kZWNvZGUtcmF3LWRhdGEuaGVscGVyJztcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENhY2hlU2VydmljZSB7XG4gICAgcHJpdmF0ZSB0dGw6IG51bWJlciA9IDYwICogNjA7IC8vIG9uZSBob3VyXG4gICAgcHJpdmF0ZSBjYWNoZUVuYWJsZWQ6IGJvb2xlYW4gPSB0cnVlO1xuICAgIHByaXZhdGUgaW52YWxpZGF0ZU9mZmxpbmU6IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgY2FjaGVTdG9yYWdlOiBDYWNoZVN0b3JhZ2VTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMubG9hZENhY2hlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGlzYWJsZSBvciBlbmFibGUgY2FjaGUuXG4gICAgICovXG4gICAgcHVibGljIGVuYWJsZUNhY2hlKGVuYWJsZTogYm9vbGVhbiA9IHRydWUpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5jYWNoZUVuYWJsZWQgPSBlbmFibGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0IGlmIGV4cGlyZWQgY2FjaGUgc2hvdWxkIGJlIGludmFsaWRhdGVkIGlmIGRldmljZSBpcyBvZmZsaW5lLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXRPZmZsaW5lSW52YWxpZGF0ZShvZmZsaW5lSW52YWxpZGF0ZTogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICB0aGlzLmludmFsaWRhdGVPZmZsaW5lID0gIW9mZmxpbmVJbnZhbGlkYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldCBkZWZhdWx0IFRUTC5cbiAgICAgKiBAcGFyYW0gdHRsIFRUTCBpbiBzZWNvbmRzLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXREZWZhdWx0VFRMKHR0bDogbnVtYmVyKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnR0bCA9IHR0bCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIHRoZSBkZXZpY2UgaXMgb25saW5lLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc09ubGluZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5vbkxpbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2F2ZXMgYW4gaXRlbSB0byB0aGUgY2FjaGUgc3RvcmFnZSB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXlcbiAgICAgKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBzdG9yZVxuICAgICAqIEBwYXJhbSBncm91cEtleSBUaGUgZ3JvdXAga2V5XG4gICAgICogQHBhcmFtIHR0bCBUaGUgVFRMIGluIHNlY29uZHNcbiAgICAgKiBAcmV0dXJucyBUaGUgc2F2ZWQgZGF0YVxuICAgICAqL1xuICAgIHB1YmxpYyBzYXZlSXRlbShrZXk6IHN0cmluZywgZGF0YTogYW55LCBncm91cEtleTogc3RyaW5nID0gJ25vbmUnLCB0dGw6IG51bWJlciA9IHRoaXMudHRsKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXMubm90RW5hYmxlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQmxvYi5uYW1lID09PSBkYXRhLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVCbG9iSXRlbShrZXksIGRhdGEsIGdyb3VwS2V5LCB0dGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXhwaXJlcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpICsgdHRsICogMTAwMDtcbiAgICAgICAgY29uc3QgdHlwZSA9IGlzSHR0cFJlc3BvbnNlKGRhdGEpID8gJ3Jlc3BvbnNlJyA6IHR5cGVvZiBkYXRhO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlU3RvcmFnZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGV4cGlyZXMsXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgZ3JvdXBLZXlcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVsZXRlcyBhbiBpdGVtIGZyb20gdGhlIGNhY2hlIHN0b3JhZ2UuXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGtleVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCB3aWxsIHJlc29sdmUgd2hlbiB0aGUgaXRlbSBpcyByZW1vdmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyByZW1vdmVJdGVtKGtleTogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXMubm90RW5hYmxlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5jYWNoZVN0b3JhZ2UucmVtb3ZlKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaXRlbXMgd2l0aCBhIGtleSB0aGF0IG1hdGNoZXMgcGF0dGVybi5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2hpY2ggd2lsbCByZXNvbHZlIHdoZW4gYWxsIHRoZSBpdGVtcyBhcmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgcmVtb3ZlSXRlbXMocGF0dGVybjogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXMubm90RW5hYmxlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoYF4ke3BhdHRlcm4uc3BsaXQoJyonKS5qb2luKCcuKicpfSRgKTtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmNhY2hlU3RvcmFnZS5hbGwoKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBpdGVtc1xuICAgICAgICAgICAgICAgIC5tYXAoKGl0ZW0pID0+IGl0ZW0ua2V5KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGtleSkgPT4ga2V5ICYmIHJlZ2V4LnRlc3Qoa2V5KSlcbiAgICAgICAgICAgICAgICAubWFwKChrZXkpID0+IHRoaXMucmVtb3ZlSXRlbShrZXkpKVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgaXRlbSBmcm9tIGNhY2hlIHdpdGhvdXQgY2hlY2tpbmcgaWYgaXQgaXMgZXhwaXJlZC5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5XG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHdpbGwgcmVzb2x2ZSB3aXRoIHRoZSBkYXRhIGZyb20gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRSYXdJdGVtKGtleTogc3RyaW5nKTogUHJvbWlzZTxTdG9yYWdlQ2FjaGVJdGVtPiB7XG4gICAgICAgIGlmICghdGhpcy5jYWNoZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2VzLm5vdEVuYWJsZWQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmNhY2hlU3RvcmFnZS5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICghIWRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCcnKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlcy5ub3RGb3VuZCArIGtleSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBpdGVtcyBmcm9tIHRoZSBjYWNoZSB3aXRob3V0IGNoZWNraW5nIGlmIHRoZXkgYXJlIGV4cGlyZWQuXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHdpbGwgcmVzb3ZlIHdpdGggYWxsIHRoZSBpdGVtcyBpbiB0aGUgY2FjaGUuXG4gICAgICovXG4gICAgcHVibGljIGdldFJhd0l0ZW1zKCk6IFByb21pc2U8U3RvcmFnZUNhY2hlSXRlbVtdPiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlU3RvcmFnZS5hbGwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVjayBzaWYgaXRlbSBleGlzdHMgaW4gY2FjaGUgcmVnYXJkbGVzcyBpZiBleHBpcmVkIG9yIG5vdC5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5XG4gICAgICogQHJldHVybnMgQSBib29sZWFuIHdoaWNoIHdpbGwgYmUgdHJ1ZSB0aGUga2V5IGlmIGV4aXN0cy5cbiAgICAgKi9cbiAgICBwdWJsaWMgaXRlbUV4aXN0cyhrZXk6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbiB8IHN0cmluZz4ge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVFbmFibGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlcy5ub3RFbmFibGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlU3RvcmFnZS5leGlzdHMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGl0ZW0gZnJvbSBjYWNoZSB3aXRoIGV4cGlyZSBjaGVjay5cbiAgICAgKiBAcGFyYW0ga2V5IFRoZSB1bmlxdWUga2V5XG4gICAgICogQHJldHVybnMgVGhlIGRhdGEgZnJvbSB0aGUgY2FjaGVcbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgZ2V0SXRlbTxUID0gYW55PihrZXk6IHN0cmluZyk6IFByb21pc2U8VD4ge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVFbmFibGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlcy5ub3RFbmFibGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCB0aGlzLmdldFJhd0l0ZW0oa2V5KTtcblxuICAgICAgICBpZiAoZGF0YS5leHBpcmVzIDwgbmV3IERhdGUoKS5nZXRUaW1lKCkgJiYgKHRoaXMuaW52YWxpZGF0ZU9mZmxpbmUgfHwgdGhpcy5pc09ubGluZSgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXMuZXhwaXJlZCArIGtleSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVjb2RlUmF3RGF0YShkYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIG9yIHNldHMgYW4gaXRlbSBpbiB0aGUgY2FjaGUgc3RvcmFnZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXlcbiAgICAgKiBAcGFyYW0gZmFjdG9yeSBUaGUgZmFjdG9yeSB0byB1cGRhdGUgdGhlIHZhbHVlIHdpdGggaWYgaXQncyBub3QgcHJlc2VudC5cbiAgICAgKiBAcGFyYW0gZ3JvdXBLZXkgVGhlIGdyb3VwIGtleVxuICAgICAqIEBwYXJhbSB0dGwgVGhlIFRUTCBpbiBzZWNvbmRzLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aXRoIHRoZSBkYXRhLlxuICAgICAqL1xuICAgIHB1YmxpYyBhc3luYyBnZXRPclNldEl0ZW08VD4oa2V5OiBzdHJpbmcsIGZhY3Rvcnk6ICgpID0+IFByb21pc2U8VD4sIGdyb3VwS2V5Pzogc3RyaW5nLCB0dGw/OiBudW1iZXIpOiBQcm9taXNlPFQ+IHtcbiAgICAgICAgbGV0IHZhbDogVDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFsID0gYXdhaXQgdGhpcy5nZXRJdGVtPFQ+KGtleSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB2YWwgPSBhd2FpdCBmYWN0b3J5KCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNhdmVJdGVtKGtleSwgdmFsLCBncm91cEtleSwgdHRsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYW4gaXRlbSBmcm9tIHRoZSBjYWNoZSwgaWYgaXQncyBub3QgdGhlcmUgaXQgd2lsbCB1c2UgdGhlIHByb3ZpZGVkIG9ic2VydmFibGUgdG8gc2V0IHRoZSB2YWx1ZSBhbmQgcmV0dXJuIGl0LlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXlcbiAgICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSBUaGUgb2JzZXJ2YWJsZSB0byBwcm92aWRlIHRoZSBkYXRhIGlmIGl0J3Mgbm90IHByZXNlbnQgaW4gdGhlIGNhY2hlLlxuICAgICAqIEBwYXJhbSBncm91cEtleSBUaGUgZ3JvdXAga2V5XG4gICAgICogQHBhcmFtIHR0bCBUaGUgVFRMIGluIHNlY29uZHNcbiAgICAgKiBAcmV0dXJucyBBbiBvYnNlcnZhYmxlIHdpdGggdGhlIGRhdGEgZnJvbSB0aGUgY2FjaGUgb3IgcHJvdmlkZWQgb2JzZXJ2YWJsZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbG9hZEZyb21PYnNlcnZhYmxlPFQgPSBhbnk+KGtleTogc3RyaW5nLCBvYnNlcnZhYmxlOiBhbnksIGdyb3VwS2V5Pzogc3RyaW5nLCB0dGw/OiBudW1iZXIpOiBPYnNlcnZhYmxlPFQ+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlRW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICAgIH1cblxuICAgICAgICBvYnNlcnZhYmxlID0gb2JzZXJ2YWJsZS5waXBlKHNoYXJlKCkpO1xuXG4gICAgICAgIHJldHVybiBkZWZlcigoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZnJvbSh0aGlzLmdldEl0ZW0oa2V5KSkucGlwZShcbiAgICAgICAgICAgICAgICBjYXRjaEVycm9yKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGUuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgICAgICAgICAgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNhdmVJdGVtKGtleSwgcmVzLCBncm91cEtleSwgdHRsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGU7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExvYWRzIGFuIGl0ZW0gZnJvbSBjYWNoZSByZWdhcmRsZXNzIG9mIGV4cGlyeS5cbiAgICAgKiBJZiB0aGUgZGVsYXkgdHlwZSBpcyBzZXQgdG8gZXhwaXJlZCBpdCB3aWxsIG9ubHkgZ2V0IGRhdGEgZnJvbSB0aGUgb2JzZXJ2YWJsZSB3aGVuIHRoZSBpdGVtIGlzIGV4cGlyZWQuXG4gICAgICogSWYgdGhlIGRlbGF5IHR5cGUgaXMgc2V0IHRvIGFsbCBpdCB3aWxsIGFsd2F5cyBnZXQgZGF0YSBmcm9tIHRoZSBvYnNlcnZhYmxlLlxuICAgICAqIEBwYXJhbSBrZXkgVGhlIHVuaXF1ZSBrZXlcbiAgICAgKiBAcGFyYW0gb2JzZXJ2YWJsZSBUaGUgb2JzZXJ2YWJsZSB3aXRoIGRhdGEuXG4gICAgICogQHBhcmFtIGdyb3VwS2V5IFRoZSBncm91cCBrZXlcbiAgICAgKiBAcGFyYW0gdHRsIFRoZSBUVEwgaW4gc2Vjb25kc1xuICAgICAqIEBwYXJhbSBkZWxheVR5cGUgVGhlIGRlbGF5IHR5cGUsIGRlZmF1bHRzIHRvIGV4cGlyZWQuXG4gICAgICogQHBhcmFtIG1ldGFLZXkgVGhlIHByb3BlcnR5IG9uIFQgdG8gd2hpY2ggdG8gYXNzaWduIG1ldGEgZGF0YS5cbiAgICAgKiBAcmV0dXJucyBBbiBvYnNlcnZhYmxlIHdoaWNoIHdpbGwgZW1pdCB0aGUgZGF0YS5cbiAgICAgKi9cbiAgICBwdWJsaWMgbG9hZEZyb21EZWxheWVkT2JzZXJ2YWJsZTxUID0gYW55PihcbiAgICAgICAga2V5OiBzdHJpbmcsXG4gICAgICAgIG9ic2VydmFibGU6IE9ic2VydmFibGU8VD4sXG4gICAgICAgIGdyb3VwS2V5Pzogc3RyaW5nLFxuICAgICAgICB0dGw6IG51bWJlciA9IHRoaXMudHRsLFxuICAgICAgICBkZWxheVR5cGU6IHN0cmluZyA9ICdleHBpcmVkJyxcbiAgICAgICAgbWV0YUtleT86IHN0cmluZ1xuICAgICk6IE9ic2VydmFibGU8VD4ge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JzZXJ2YWJsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVTdWJqZWN0ID0gbmV3IFN1YmplY3Q8VD4oKTtcbiAgICAgICAgb2JzZXJ2YWJsZSA9IG9ic2VydmFibGUucGlwZShzaGFyZSgpKTtcblxuICAgICAgICBjb25zdCBzdWJzY3JpYmVPcmlnaW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBvYnNlcnZhYmxlLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICAocmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZUl0ZW0oa2V5LCByZXMsIGdyb3VwS2V5LCB0dGwpO1xuICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlU3ViamVjdC5uZXh0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGVTdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGVTdWJqZWN0LmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9ic2VydmFibGVTdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldEl0ZW08VD4oa2V5KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobWV0YUtleSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW21ldGFLZXldID0gZGF0YVttZXRhS2V5XSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVttZXRhS2V5XS5mcm9tQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYnNlcnZhYmxlU3ViamVjdC5uZXh0KGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlbGF5VHlwZSA9PT0gJ2FsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlT3JpZ2luKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2YWJsZVN1YmplY3QuY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5nZXRSYXdJdGVtKGtleSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZGVjb2RlUmF3RGF0YShyZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGFLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbbWV0YUtleV0gPSByZXN1bHRbbWV0YUtleV0gfHwge307XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W21ldGFLZXldLmZyb21DYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBvYnNlcnZhYmxlU3ViamVjdC5uZXh0KHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVPcmlnaW4oKTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHN1YnNjcmliZU9yaWdpbigpKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBvYnNlcnZhYmxlU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIGNvbXBsZXRlIGNhY2hlIGNsZWFyXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gdGhlIGNhY2hlIHN0b3JhZ2UgaXMgY2xlYXJlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2xlYXJBbGwoKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXMubm90RW5hYmxlZCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5yZXNldERhdGFiYXNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgZXhwaXJlZCBpdGVtcyBmcm9tIHRoZSBjYWNoZS5cbiAgICAgKiBAcGFyYW0gaWdub3JlT25saW5lU3RhdHVzIElnbm9yZXMgdGhlIG9ubGluZSBzdGF0dXMsIGRlZmF1bHRzIHRvIGZhbHNlLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGFsbCBleHBpcmVkIGl0ZW1zIGFyZSBjbGVhcmVkIGZyb20gY2FjaGUgc3RvcmFnZS5cbiAgICAgKi9cbiAgICBwdWJsaWMgYXN5bmMgY2xlYXJFeHBpcmVkKGlnbm9yZU9ubGluZVN0YXR1cyA9IGZhbHNlKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgaWYgKCF0aGlzLmNhY2hlRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZXMubm90RW5hYmxlZCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaXNPbmxpbmUoKSAmJiAhaWdub3JlT25saW5lU3RhdHVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlcy5icm93c2VyT2ZmbGluZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpdGVtcyA9IGF3YWl0IHRoaXMuY2FjaGVTdG9yYWdlLmFsbCgpO1xuICAgICAgICBjb25zdCBkYXRldGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uZXhwaXJlcyA8IGRhdGV0aW1lKS5tYXAoKGl0ZW0pID0+IHRoaXMucmVtb3ZlSXRlbShpdGVtLmtleSkpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBpdGVtIHdpdGggc3BlY2lmaWVkIGdyb3VwXG4gICAgICogQHBhcmFtIGdyb3VwS2V5IFRoZSBncm91cCBrZXlcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgd2hlbiBhbGwgdGhlIGl0ZW1zIGluIHRoZSBncm91cCBoYXZlIGJlZW4gY2xlYXJlZC5cbiAgICAgKi9cbiAgICBhc3luYyBjbGVhckdyb3VwKGdyb3VwS2V5OiBzdHJpbmcpOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVFbmFibGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlcy5ub3RFbmFibGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGl0ZW1zID0gYXdhaXQgdGhpcy5jYWNoZVN0b3JhZ2UuYWxsKCk7XG5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5ncm91cEtleSA9PT0gZ3JvdXBLZXkpLm1hcCgoaXRlbSkgPT4gdGhpcy5yZW1vdmVJdGVtKGl0ZW0ua2V5KSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGNhY2hlIHN0b3JhZ2UuXG4gICAgICogSWYgaXQgZmFpbHMgaXQgd2lsbCBwcm92aWRlIGFuZCBlcnJvciBtZXNzYWdlLlxuICAgICAqL1xuICAgIHByaXZhdGUgYXN5bmMgbG9hZENhY2hlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jYWNoZVN0b3JhZ2UuY3JlYXRlKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvck1lc3NhZ2VzLmluaXRpYWxpemF0aW9uLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXNldHMgdGhlIHN0b3JhZ2UgYmFjayB0byBiZWluZyBlbXB0eS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGFzeW5jIHJlc2V0RGF0YWJhc2UoKTogUHJvbWlzZTxhbnk+IHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBhd2FpdCB0aGlzLmNhY2hlU3RvcmFnZS5hbGwoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zLm1hcCgoaXRlbSkgPT4gdGhpcy5yZW1vdmVJdGVtKGl0ZW0ua2V5KSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNhdmVzIGEgYmxvYiBpdGVtIHRvIHRoZSBjYWNoZSBzdG9yYWdlIHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIGtleSBUaGUgdW5pcXVlIGtleVxuICAgICAqIEBwYXJhbSBibG9iIFRoZSBibG9iIHRvIHN0b3JlXG4gICAgICogQHBhcmFtIGdyb3VwS2V5IFRoZSBncm91cCBrZXlcbiAgICAgKiBAcGFyYW0gdHRsIFRoZSBUVEwgaW4gc2Vjb25kc1xuICAgICAqIEByZXR1cm5zIFRoZSBzYXZlZCBkYXRhXG4gICAgICovXG4gICAgcHJpdmF0ZSBhc3luYyBzYXZlQmxvYkl0ZW0oXG4gICAgICAgIGtleTogc3RyaW5nLFxuICAgICAgICBibG9iOiBhbnksXG4gICAgICAgIGdyb3VwS2V5OiBzdHJpbmcgPSAnbm9uZScsXG4gICAgICAgIHR0bDogbnVtYmVyID0gdGhpcy50dGxcbiAgICApOiBQcm9taXNlPGFueT4ge1xuICAgICAgICBpZiAoIXRoaXMuY2FjaGVFbmFibGVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlcy5ub3RFbmFibGVkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV4cGlyZXMgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHR0bCAqIDEwMDA7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBibG9iLnR5cGU7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NGRhdGEgPSBhd2FpdCBjb252ZXJ0QmxvYlRvQmFzZTY0KGJsb2IpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBKU09OLnN0cmluZ2lmeShiYXNlNjRkYXRhKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVTdG9yYWdlLnNldChrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICBleHBpcmVzLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgZ3JvdXBLZXlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==