(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/common/http'), require('@ionic/storage-angular')) :
    typeof define === 'function' && define.amd ? define('ionic-cache', ['exports', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/common/http', '@ionic/storage-angular'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ionic-cache'] = {}, global.ng.core, global.rxjs, global.rxjs.operators, global.ng.common.http, global.ionicStorageAngular));
}(this, (function (exports, i0, rxjs, operators, http, i1) { 'use strict';

    function _interopNamespace(e) {
        if (e && e.__esModule) return e;
        var n = Object.create(null);
        if (e) {
            Object.keys(e).forEach(function (k) {
                if (k !== 'default') {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () {
                            return e[k];
                        }
                    });
                }
            });
        }
        n['default'] = e;
        return Object.freeze(n);
    }

    var i0__namespace = /*#__PURE__*/_interopNamespace(i0);
    var i1__namespace = /*#__PURE__*/_interopNamespace(i1);

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || from);
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var errorMessages = {
        initialization: 'Cache initialization error: ',
        notEnabled: 'Cache is not enabled.',
        expired: 'Cache entry already expired: ',
        notFound: 'No such key: ',
        browserOffline: 'No entries were deleted, because browser is offline.'
    };

    /**
     * Checks if it's a HttpResponse
     * @param data The variable to test
     * @return The data from cache
     */
    function isHttpResponse(data) {
        var orCondition = data &&
            typeof data === 'object' &&
            data.hasOwnProperty('status') &&
            data.hasOwnProperty('statusText') &&
            data.hasOwnProperty('headers') &&
            data.hasOwnProperty('url') &&
            data.hasOwnProperty('body');
        return data && (data instanceof http.HttpResponse || orCondition);
    }

    /**
     * Decodes raw data.
     * @param data The data to decode.
     * @return The decoded data.
     */
    function convertBlobToBase64(blob) {
        return new Promise(function (resolve, reject) {
            var reader = new FileReader();
            reader.readAsDataURL(blob);
            reader.onloadend = function () {
                var base64data = reader.result;
                resolve(base64data);
            };
            reader.onerror = function (event) {
                reject(event);
                reader.abort();
            };
        });
    }

    function isJsOrResponseType(data) {
        var jsType = data.type === 'undefined' ||
            data.type === 'object' ||
            data.type === 'boolean' ||
            data.type === 'number' ||
            data.type === 'bigint' ||
            data.type === 'string' ||
            data.type === 'symbol' ||
            data.type === 'function';
        var responseType = data.type === 'response';
        return responseType || jsType;
    }

    function decodeRawData(data) {
        return __awaiter(this, void 0, void 0, function () {
            var dataJson, response, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        dataJson = JSON.parse(data.value);
                        if (!isJsOrResponseType(data)) return [3 /*break*/, 1];
                        if (isHttpResponse(dataJson)) {
                            response = {
                                body: dataJson._body || dataJson.body,
                                status: dataJson.status,
                                headers: dataJson.headers,
                                statusText: dataJson.statusText,
                                url: dataJson.url
                            };
                            return [2 /*return*/, new http.HttpResponse(response)];
                        }
                        return [2 /*return*/, dataJson];
                    case 1: return [4 /*yield*/, fetch(dataJson)];
                    case 2:
                        response = _a.sent();
                        return [2 /*return*/, response.blob()];
                }
            });
        });
    }

    var defaultConfig = {
        keyPrefix: ''
    };

    var CONFIG = new i0.InjectionToken('CONFIG');
    var CacheModule = /** @class */ (function () {
        function CacheModule() {
        }
        CacheModule.forRoot = function (cacheConfig) {
            return {
                ngModule: CacheModule,
                providers: [
                    {
                        provide: CONFIG,
                        useValue: Object.assign(Object.assign({}, defaultConfig), cacheConfig)
                    },
                    CacheStorageService,
                    CacheService
                ]
            };
        };
        return CacheModule;
    }());
    CacheModule.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheModule, deps: [], target: i0__namespace.ɵɵFactoryTarget.NgModule });
    CacheModule.ɵmod = i0__namespace.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheModule, imports: [i1__namespace.IonicStorageModule] });
    CacheModule.ɵinj = i0__namespace.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheModule, imports: [[
                i1.IonicStorageModule.forRoot({
                    name: '__ionicCache',
                    driverOrder: ['indexeddb', 'sqlite', 'websql']
                })
            ]] });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheModule, decorators: [{
                type: i0.NgModule,
                args: [{
                        imports: [
                            i1.IonicStorageModule.forRoot({
                                name: '__ionicCache',
                                driverOrder: ['indexeddb', 'sqlite', 'websql']
                            })
                        ]
                    }]
            }] });

    var CacheStorageService = /** @class */ (function () {
        function CacheStorageService(storage, config) {
            this.storage = storage;
            this.config = config;
        }
        CacheStorageService.prototype.create = function () {
            return this.storage.create();
        };
        CacheStorageService.prototype.set = function (key, value) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.storage.set(this.buildKey(key), value)];
                });
            });
        };
        CacheStorageService.prototype.remove = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.storage.remove(this.buildKey(key))];
                });
            });
        };
        CacheStorageService.prototype.get = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                var value;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.storage.get(this.buildKey(key))];
                        case 1:
                            value = _a.sent();
                            return [2 /*return*/, !!value ? Object.assign({ key: key }, value) : null];
                    }
                });
            });
        };
        CacheStorageService.prototype.exists = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.storage.get(this.buildKey(key))];
                        case 1: return [2 /*return*/, !!(_a.sent())];
                    }
                });
            });
        };
        CacheStorageService.prototype.all = function () {
            return __awaiter(this, void 0, void 0, function () {
                var items;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            items = [];
                            return [4 /*yield*/, this.storage.forEach(function (val, key) {
                                    if (_this.isCachedItem(key, val)) {
                                        items.push(Object.assign({ key: _this.debuildKey(key) }, val));
                                    }
                                })];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, items];
                    }
                });
            });
        };
        /**
         * Returns whether or not an object is a cached item.
         */
        CacheStorageService.prototype.isCachedItem = function (key, item) {
            return item && item.expires && item.type && key.startsWith(this.config.keyPrefix);
        };
        /**
         * Makes sure that the key is prefixed properly
         */
        CacheStorageService.prototype.buildKey = function (key) {
            if (key.startsWith(this.config.keyPrefix)) {
                return key;
            }
            return this.config.keyPrefix + key;
        };
        /**
         * Makes sure that the key isn't prefixed
         */
        CacheStorageService.prototype.debuildKey = function (key) {
            if (key.startsWith(this.config.keyPrefix)) {
                return key.substr(this.config.keyPrefix.length);
            }
            return key;
        };
        return CacheStorageService;
    }());
    CacheStorageService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheStorageService, deps: [{ token: i1__namespace.Storage }, { token: CONFIG }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CacheStorageService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheStorageService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheStorageService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () {
            return [{ type: i1__namespace.Storage }, { type: undefined, decorators: [{
                            type: i0.Inject,
                            args: [CONFIG]
                        }] }];
        } });

    var CacheService = /** @class */ (function () {
        function CacheService(cacheStorage) {
            this.cacheStorage = cacheStorage;
            this.ttl = 60 * 60; // one hour
            this.cacheEnabled = true;
            this.invalidateOffline = false;
            this.loadCache();
        }
        /**
         * Disable or enable cache.
         */
        CacheService.prototype.enableCache = function (enable) {
            if (enable === void 0) { enable = true; }
            this.cacheEnabled = enable;
        };
        /**
         * Set if expired cache should be invalidated if device is offline.
         */
        CacheService.prototype.setOfflineInvalidate = function (offlineInvalidate) {
            this.invalidateOffline = !offlineInvalidate;
        };
        /**
         * Set default TTL.
         * @param ttl TTL in seconds.
         */
        CacheService.prototype.setDefaultTTL = function (ttl) {
            return (this.ttl = ttl);
        };
        /**
         * Checks if the device is online.
         */
        CacheService.prototype.isOnline = function () {
            return navigator.onLine;
        };
        /**
         * Saves an item to the cache storage with the provided options.
         * @param key The unique key
         * @param data The data to store
         * @param groupKey The group key
         * @param ttl The TTL in seconds
         * @returns The saved data
         */
        CacheService.prototype.saveItem = function (key, data, groupKey, ttl) {
            if (groupKey === void 0) { groupKey = 'none'; }
            if (ttl === void 0) { ttl = this.ttl; }
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            if (Blob.name === data.constructor.name) {
                return this.saveBlobItem(key, data, groupKey, ttl);
            }
            var expires = new Date().getTime() + ttl * 1000;
            var type = isHttpResponse(data) ? 'response' : typeof data;
            var value = JSON.stringify(data);
            return this.cacheStorage.set(key, {
                value: value,
                expires: expires,
                type: type,
                groupKey: groupKey
            });
        };
        /**
         * Deletes an item from the cache storage.
         * @param key The unique key
         * @returns A promise which will resolve when the item is removed.
         */
        CacheService.prototype.removeItem = function (key) {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            return this.cacheStorage.remove(key);
        };
        /**
         * Removes all items with a key that matches pattern.
         * @returns A promise which will resolve when all the items are removed.
         */
        CacheService.prototype.removeItems = function (pattern) {
            return __awaiter(this, void 0, void 0, function () {
                var regex, items;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.cacheEnabled) {
                                throw new Error(errorMessages.notEnabled);
                            }
                            regex = new RegExp("^" + pattern.split('*').join('.*') + "$");
                            return [4 /*yield*/, this.cacheStorage.all()];
                        case 1:
                            items = _a.sent();
                            return [2 /*return*/, Promise.all(items
                                    .map(function (item) { return item.key; })
                                    .filter(function (key) { return key && regex.test(key); })
                                    .map(function (key) { return _this.removeItem(key); }))];
                    }
                });
            });
        };
        /**
         * Gets item from cache without checking if it is expired.
         * @param key The unique key
         * @returns A promise which will resolve with the data from the cache.
         */
        CacheService.prototype.getRawItem = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                var data, err_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.cacheEnabled) {
                                throw new Error(errorMessages.notEnabled);
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.cacheStorage.get(key)];
                        case 2:
                            data = _a.sent();
                            if (!!data) {
                                return [2 /*return*/, data];
                            }
                            throw new Error('');
                        case 3:
                            err_1 = _a.sent();
                            throw new Error(errorMessages.notFound + key);
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Gets all items from the cache without checking if they are expired.
         * @returns A promise which will resove with all the items in the cache.
         */
        CacheService.prototype.getRawItems = function () {
            return this.cacheStorage.all();
        };
        /**
         * Check sif item exists in cache regardless if expired or not.
         * @param key The unique key
         * @returns A boolean which will be true the key if exists.
         */
        CacheService.prototype.itemExists = function (key) {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            return this.cacheStorage.exists(key);
        };
        /**
         * Gets item from cache with expire check.
         * @param key The unique key
         * @returns The data from the cache
         */
        CacheService.prototype.getItem = function (key) {
            return __awaiter(this, void 0, void 0, function () {
                var data;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.cacheEnabled) {
                                throw new Error(errorMessages.notEnabled);
                            }
                            return [4 /*yield*/, this.getRawItem(key)];
                        case 1:
                            data = _a.sent();
                            if (data.expires < new Date().getTime() && (this.invalidateOffline || this.isOnline())) {
                                throw new Error(errorMessages.expired + key);
                            }
                            return [2 /*return*/, decodeRawData(data)];
                    }
                });
            });
        };
        /**
         * Gets or sets an item in the cache storage
         * @param key The unique key
         * @param factory The factory to update the value with if it's not present.
         * @param groupKey The group key
         * @param ttl The TTL in seconds.
         * @returns A promise which resolves with the data.
         */
        CacheService.prototype.getOrSetItem = function (key, factory, groupKey, ttl) {
            return __awaiter(this, void 0, void 0, function () {
                var val, error_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, 2, , 5]);
                            return [4 /*yield*/, this.getItem(key)];
                        case 1:
                            val = _a.sent();
                            return [3 /*break*/, 5];
                        case 2:
                            error_1 = _a.sent();
                            return [4 /*yield*/, factory()];
                        case 3:
                            val = _a.sent();
                            return [4 /*yield*/, this.saveItem(key, val, groupKey, ttl)];
                        case 4:
                            _a.sent();
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/, val];
                    }
                });
            });
        };
        /**
         * Loads an item from the cache, if it's not there it will use the provided observable to set the value and return it.
         * @param key The unique key
         * @param observable The observable to provide the data if it's not present in the cache.
         * @param groupKey The group key
         * @param ttl The TTL in seconds
         * @returns An observable with the data from the cache or provided observable.
         */
        CacheService.prototype.loadFromObservable = function (key, observable, groupKey, ttl) {
            var _this = this;
            if (!this.cacheEnabled) {
                return observable;
            }
            observable = observable.pipe(operators.share());
            return rxjs.defer(function () {
                return rxjs.from(_this.getItem(key)).pipe(operators.catchError(function (e) {
                    observable.subscribe(function (res) {
                        return _this.saveItem(key, res, groupKey, ttl);
                    }, function (error) {
                        return rxjs.throwError(error);
                    });
                    return observable;
                }));
            });
        };
        /**
         * Loads an item from cache regardless of expiry.
         * If the delay type is set to expired it will only get data from the observable when the item is expired.
         * If the delay type is set to all it will always get data from the observable.
         * @param key The unique key
         * @param observable The observable with data.
         * @param groupKey The group key
         * @param ttl The TTL in seconds
         * @param delayType The delay type, defaults to expired.
         * @param metaKey The property on T to which to assign meta data.
         * @returns An observable which will emit the data.
         */
        CacheService.prototype.loadFromDelayedObservable = function (key, observable, groupKey, ttl, delayType, metaKey) {
            var _this = this;
            if (ttl === void 0) { ttl = this.ttl; }
            if (delayType === void 0) { delayType = 'expired'; }
            if (!this.cacheEnabled) {
                return observable;
            }
            var observableSubject = new rxjs.Subject();
            observable = observable.pipe(operators.share());
            var subscribeOrigin = function () {
                observable.subscribe(function (res) {
                    _this.saveItem(key, res, groupKey, ttl);
                    observableSubject.next(res);
                    observableSubject.complete();
                }, function (err) {
                    observableSubject.error(err);
                }, function () {
                    observableSubject.complete();
                });
            };
            this.getItem(key)
                .then(function (data) {
                if (metaKey) {
                    data[metaKey] = data[metaKey] || {};
                    data[metaKey].fromCache = true;
                }
                observableSubject.next(data);
                if (delayType === 'all') {
                    subscribeOrigin();
                }
                else {
                    observableSubject.complete();
                }
            })
                .catch(function (e) {
                _this.getRawItem(key)
                    .then(function (res) { return __awaiter(_this, void 0, void 0, function () {
                    var result;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, decodeRawData(res)];
                            case 1:
                                result = _a.sent();
                                if (metaKey) {
                                    result[metaKey] = result[metaKey] || {};
                                    result[metaKey].fromCache = true;
                                }
                                observableSubject.next(result);
                                subscribeOrigin();
                                return [2 /*return*/];
                        }
                    });
                }); })
                    .catch(function () { return subscribeOrigin(); });
            });
            return observableSubject.asObservable();
        };
        /**
         * Perform complete cache clear
         * @returns A promise which resolves when the cache storage is cleared.
         */
        CacheService.prototype.clearAll = function () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            return this.resetDatabase();
        };
        /**
         * Removes all expired items from the cache.
         * @param ignoreOnlineStatus Ignores the online status, defaults to false.
         * @returns A promise which resolves when all expired items are cleared from cache storage.
         */
        CacheService.prototype.clearExpired = function (ignoreOnlineStatus) {
            if (ignoreOnlineStatus === void 0) { ignoreOnlineStatus = false; }
            return __awaiter(this, void 0, void 0, function () {
                var items, datetime;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.cacheEnabled) {
                                throw new Error(errorMessages.notEnabled);
                            }
                            if (!this.isOnline() && !ignoreOnlineStatus) {
                                throw new Error(errorMessages.browserOffline);
                            }
                            return [4 /*yield*/, this.cacheStorage.all()];
                        case 1:
                            items = _a.sent();
                            datetime = new Date().getTime();
                            return [2 /*return*/, Promise.all(items.filter(function (item) { return item.expires < datetime; }).map(function (item) { return _this.removeItem(item.key); }))];
                    }
                });
            });
        };
        /**
         * Removes all item with specified group
         * @param groupKey The group key
         * @returns A promise which resolves when all the items in the group have been cleared.
         */
        CacheService.prototype.clearGroup = function (groupKey) {
            return __awaiter(this, void 0, void 0, function () {
                var items;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.cacheEnabled) {
                                throw new Error(errorMessages.notEnabled);
                            }
                            return [4 /*yield*/, this.cacheStorage.all()];
                        case 1:
                            items = _a.sent();
                            return [2 /*return*/, Promise.all(items.filter(function (item) { return item.groupKey === groupKey; }).map(function (item) { return _this.removeItem(item.key); }))];
                    }
                });
            });
        };
        /**
         * Creates the cache storage.
         * If it fails it will provide and error message.
         */
        CacheService.prototype.loadCache = function () {
            return __awaiter(this, void 0, void 0, function () {
                var error_2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.cacheEnabled) {
                                return [2 /*return*/];
                            }
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.cacheStorage.create()];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            error_2 = _a.sent();
                            this.cacheEnabled = false;
                            console.error(errorMessages.initialization, error_2);
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Resets the storage back to being empty.
         */
        CacheService.prototype.resetDatabase = function () {
            return __awaiter(this, void 0, void 0, function () {
                var items;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.cacheStorage.all()];
                        case 1:
                            items = _a.sent();
                            return [2 /*return*/, Promise.all(items.map(function (item) { return _this.removeItem(item.key); }))];
                    }
                });
            });
        };
        /**
         * Saves a blob item to the cache storage with the provided options.
         * @param key The unique key
         * @param blob The blob to store
         * @param groupKey The group key
         * @param ttl The TTL in seconds
         * @returns The saved data
         */
        CacheService.prototype.saveBlobItem = function (key, blob, groupKey, ttl) {
            if (groupKey === void 0) { groupKey = 'none'; }
            if (ttl === void 0) { ttl = this.ttl; }
            return __awaiter(this, void 0, void 0, function () {
                var expires, type, base64data, value, error_3;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.cacheEnabled) {
                                throw new Error(errorMessages.notEnabled);
                            }
                            expires = new Date().getTime() + ttl * 1000;
                            type = blob.type;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, convertBlobToBase64(blob)];
                        case 2:
                            base64data = _a.sent();
                            value = JSON.stringify(base64data);
                            return [2 /*return*/, this.cacheStorage.set(key, {
                                    value: value,
                                    expires: expires,
                                    type: type,
                                    groupKey: groupKey
                                })];
                        case 3:
                            error_3 = _a.sent();
                            throw new Error(error_3);
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        return CacheService;
    }());
    CacheService.ɵfac = i0__namespace.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheService, deps: [{ token: CacheStorageService }], target: i0__namespace.ɵɵFactoryTarget.Injectable });
    CacheService.ɵprov = i0__namespace.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheService });
    i0__namespace.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0__namespace, type: CacheService, decorators: [{
                type: i0.Injectable
            }], ctorParameters: function () { return [{ type: CacheStorageService }]; } });

    /**
     * Generated bundle index. Do not edit.
     */

    exports.CONFIG = CONFIG;
    exports.CacheModule = CacheModule;
    exports.CacheService = CacheService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ionic-cache.umd.js.map
