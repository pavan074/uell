import { __awaiter } from 'tslib';
import * as i0 from '@angular/core';
import { InjectionToken, NgModule, Injectable, Inject } from '@angular/core';
import { defer, from, throwError, Subject } from 'rxjs';
import { share, catchError } from 'rxjs/operators';
import { HttpResponse } from '@angular/common/http';
import * as i1 from '@ionic/storage-angular';
import { IonicStorageModule } from '@ionic/storage-angular';

const errorMessages = {
    initialization: 'Cache initialization error: ',
    notEnabled: 'Cache is not enabled.',
    expired: 'Cache entry already expired: ',
    notFound: 'No such key: ',
    browserOffline: 'No entries were deleted, because browser is offline.'
};

/**
 * Checks if it's a HttpResponse
 * @param data The variable to test
 * @return The data from cache
 */
function isHttpResponse(data) {
    const orCondition = data &&
        typeof data === 'object' &&
        data.hasOwnProperty('status') &&
        data.hasOwnProperty('statusText') &&
        data.hasOwnProperty('headers') &&
        data.hasOwnProperty('url') &&
        data.hasOwnProperty('body');
    return data && (data instanceof HttpResponse || orCondition);
}

/**
 * Decodes raw data.
 * @param data The data to decode.
 * @return The decoded data.
 */
function convertBlobToBase64(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(blob);
        reader.onloadend = () => {
            const base64data = reader.result;
            resolve(base64data);
        };
        reader.onerror = (event) => {
            reject(event);
            reader.abort();
        };
    });
}

function isJsOrResponseType(data) {
    const jsType = data.type === 'undefined' ||
        data.type === 'object' ||
        data.type === 'boolean' ||
        data.type === 'number' ||
        data.type === 'bigint' ||
        data.type === 'string' ||
        data.type === 'symbol' ||
        data.type === 'function';
    const responseType = data.type === 'response';
    return responseType || jsType;
}

function decodeRawData(data) {
    return __awaiter(this, void 0, void 0, function* () {
        const dataJson = JSON.parse(data.value);
        if (isJsOrResponseType(data)) {
            if (isHttpResponse(dataJson)) {
                const response = {
                    body: dataJson._body || dataJson.body,
                    status: dataJson.status,
                    headers: dataJson.headers,
                    statusText: dataJson.statusText,
                    url: dataJson.url
                };
                return new HttpResponse(response);
            }
            return dataJson;
        }
        else {
            // Technique derived from: https://stackoverflow.com/a/36183085
            const response = yield fetch(dataJson);
            return response.blob();
        }
    });
}

const defaultConfig = {
    keyPrefix: ''
};

const CONFIG = new InjectionToken('CONFIG');
class CacheModule {
    static forRoot(cacheConfig) {
        return {
            ngModule: CacheModule,
            providers: [
                {
                    provide: CONFIG,
                    useValue: Object.assign(Object.assign({}, defaultConfig), cacheConfig)
                },
                CacheStorageService,
                CacheService
            ]
        };
    }
}
CacheModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
CacheModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheModule, imports: [i1.IonicStorageModule] });
CacheModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheModule, imports: [[
            IonicStorageModule.forRoot({
                name: '__ionicCache',
                driverOrder: ['indexeddb', 'sqlite', 'websql']
            })
        ]] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheModule, decorators: [{
            type: NgModule,
            args: [{
                    imports: [
                        IonicStorageModule.forRoot({
                            name: '__ionicCache',
                            driverOrder: ['indexeddb', 'sqlite', 'websql']
                        })
                    ]
                }]
        }] });

class CacheStorageService {
    constructor(storage, config) {
        this.storage = storage;
        this.config = config;
    }
    create() {
        return this.storage.create();
    }
    set(key, value) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.storage.set(this.buildKey(key), value);
        });
    }
    remove(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.storage.remove(this.buildKey(key));
        });
    }
    get(key) {
        return __awaiter(this, void 0, void 0, function* () {
            const value = yield this.storage.get(this.buildKey(key));
            return !!value ? Object.assign({ key }, value) : null;
        });
    }
    exists(key) {
        return __awaiter(this, void 0, void 0, function* () {
            return !!(yield this.storage.get(this.buildKey(key)));
        });
    }
    all() {
        return __awaiter(this, void 0, void 0, function* () {
            const items = [];
            yield this.storage.forEach((val, key) => {
                if (this.isCachedItem(key, val)) {
                    items.push(Object.assign({ key: this.debuildKey(key) }, val));
                }
            });
            return items;
        });
    }
    /**
     * Returns whether or not an object is a cached item.
     */
    isCachedItem(key, item) {
        return item && item.expires && item.type && key.startsWith(this.config.keyPrefix);
    }
    /**
     * Makes sure that the key is prefixed properly
     */
    buildKey(key) {
        if (key.startsWith(this.config.keyPrefix)) {
            return key;
        }
        return this.config.keyPrefix + key;
    }
    /**
     * Makes sure that the key isn't prefixed
     */
    debuildKey(key) {
        if (key.startsWith(this.config.keyPrefix)) {
            return key.substr(this.config.keyPrefix.length);
        }
        return key;
    }
}
CacheStorageService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheStorageService, deps: [{ token: i1.Storage }, { token: CONFIG }], target: i0.ɵɵFactoryTarget.Injectable });
CacheStorageService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheStorageService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheStorageService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: i1.Storage }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [CONFIG]
                }] }]; } });

class CacheService {
    constructor(cacheStorage) {
        this.cacheStorage = cacheStorage;
        this.ttl = 60 * 60; // one hour
        this.cacheEnabled = true;
        this.invalidateOffline = false;
        this.loadCache();
    }
    /**
     * Disable or enable cache.
     */
    enableCache(enable = true) {
        this.cacheEnabled = enable;
    }
    /**
     * Set if expired cache should be invalidated if device is offline.
     */
    setOfflineInvalidate(offlineInvalidate) {
        this.invalidateOffline = !offlineInvalidate;
    }
    /**
     * Set default TTL.
     * @param ttl TTL in seconds.
     */
    setDefaultTTL(ttl) {
        return (this.ttl = ttl);
    }
    /**
     * Checks if the device is online.
     */
    isOnline() {
        return navigator.onLine;
    }
    /**
     * Saves an item to the cache storage with the provided options.
     * @param key The unique key
     * @param data The data to store
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns The saved data
     */
    saveItem(key, data, groupKey = 'none', ttl = this.ttl) {
        if (!this.cacheEnabled) {
            throw new Error(errorMessages.notEnabled);
        }
        if (Blob.name === data.constructor.name) {
            return this.saveBlobItem(key, data, groupKey, ttl);
        }
        const expires = new Date().getTime() + ttl * 1000;
        const type = isHttpResponse(data) ? 'response' : typeof data;
        const value = JSON.stringify(data);
        return this.cacheStorage.set(key, {
            value,
            expires,
            type,
            groupKey
        });
    }
    /**
     * Deletes an item from the cache storage.
     * @param key The unique key
     * @returns A promise which will resolve when the item is removed.
     */
    removeItem(key) {
        if (!this.cacheEnabled) {
            throw new Error(errorMessages.notEnabled);
        }
        return this.cacheStorage.remove(key);
    }
    /**
     * Removes all items with a key that matches pattern.
     * @returns A promise which will resolve when all the items are removed.
     */
    removeItems(pattern) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            const regex = new RegExp(`^${pattern.split('*').join('.*')}$`);
            const items = yield this.cacheStorage.all();
            return Promise.all(items
                .map((item) => item.key)
                .filter((key) => key && regex.test(key))
                .map((key) => this.removeItem(key)));
        });
    }
    /**
     * Gets item from cache without checking if it is expired.
     * @param key The unique key
     * @returns A promise which will resolve with the data from the cache.
     */
    getRawItem(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            try {
                const data = yield this.cacheStorage.get(key);
                if (!!data) {
                    return data;
                }
                throw new Error('');
            }
            catch (err) {
                throw new Error(errorMessages.notFound + key);
            }
        });
    }
    /**
     * Gets all items from the cache without checking if they are expired.
     * @returns A promise which will resove with all the items in the cache.
     */
    getRawItems() {
        return this.cacheStorage.all();
    }
    /**
     * Check sif item exists in cache regardless if expired or not.
     * @param key The unique key
     * @returns A boolean which will be true the key if exists.
     */
    itemExists(key) {
        if (!this.cacheEnabled) {
            throw new Error(errorMessages.notEnabled);
        }
        return this.cacheStorage.exists(key);
    }
    /**
     * Gets item from cache with expire check.
     * @param key The unique key
     * @returns The data from the cache
     */
    getItem(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            const data = yield this.getRawItem(key);
            if (data.expires < new Date().getTime() && (this.invalidateOffline || this.isOnline())) {
                throw new Error(errorMessages.expired + key);
            }
            return decodeRawData(data);
        });
    }
    /**
     * Gets or sets an item in the cache storage
     * @param key The unique key
     * @param factory The factory to update the value with if it's not present.
     * @param groupKey The group key
     * @param ttl The TTL in seconds.
     * @returns A promise which resolves with the data.
     */
    getOrSetItem(key, factory, groupKey, ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            let val;
            try {
                val = yield this.getItem(key);
            }
            catch (error) {
                val = yield factory();
                yield this.saveItem(key, val, groupKey, ttl);
            }
            return val;
        });
    }
    /**
     * Loads an item from the cache, if it's not there it will use the provided observable to set the value and return it.
     * @param key The unique key
     * @param observable The observable to provide the data if it's not present in the cache.
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns An observable with the data from the cache or provided observable.
     */
    loadFromObservable(key, observable, groupKey, ttl) {
        if (!this.cacheEnabled) {
            return observable;
        }
        observable = observable.pipe(share());
        return defer(() => {
            return from(this.getItem(key)).pipe(catchError((e) => {
                observable.subscribe((res) => {
                    return this.saveItem(key, res, groupKey, ttl);
                }, (error) => {
                    return throwError(error);
                });
                return observable;
            }));
        });
    }
    /**
     * Loads an item from cache regardless of expiry.
     * If the delay type is set to expired it will only get data from the observable when the item is expired.
     * If the delay type is set to all it will always get data from the observable.
     * @param key The unique key
     * @param observable The observable with data.
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @param delayType The delay type, defaults to expired.
     * @param metaKey The property on T to which to assign meta data.
     * @returns An observable which will emit the data.
     */
    loadFromDelayedObservable(key, observable, groupKey, ttl = this.ttl, delayType = 'expired', metaKey) {
        if (!this.cacheEnabled) {
            return observable;
        }
        const observableSubject = new Subject();
        observable = observable.pipe(share());
        const subscribeOrigin = () => {
            observable.subscribe((res) => {
                this.saveItem(key, res, groupKey, ttl);
                observableSubject.next(res);
                observableSubject.complete();
            }, (err) => {
                observableSubject.error(err);
            }, () => {
                observableSubject.complete();
            });
        };
        this.getItem(key)
            .then((data) => {
            if (metaKey) {
                data[metaKey] = data[metaKey] || {};
                data[metaKey].fromCache = true;
            }
            observableSubject.next(data);
            if (delayType === 'all') {
                subscribeOrigin();
            }
            else {
                observableSubject.complete();
            }
        })
            .catch((e) => {
            this.getRawItem(key)
                .then((res) => __awaiter(this, void 0, void 0, function* () {
                const result = yield decodeRawData(res);
                if (metaKey) {
                    result[metaKey] = result[metaKey] || {};
                    result[metaKey].fromCache = true;
                }
                observableSubject.next(result);
                subscribeOrigin();
            }))
                .catch(() => subscribeOrigin());
        });
        return observableSubject.asObservable();
    }
    /**
     * Perform complete cache clear
     * @returns A promise which resolves when the cache storage is cleared.
     */
    clearAll() {
        if (!this.cacheEnabled) {
            throw new Error(errorMessages.notEnabled);
        }
        return this.resetDatabase();
    }
    /**
     * Removes all expired items from the cache.
     * @param ignoreOnlineStatus Ignores the online status, defaults to false.
     * @returns A promise which resolves when all expired items are cleared from cache storage.
     */
    clearExpired(ignoreOnlineStatus = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            if (!this.isOnline() && !ignoreOnlineStatus) {
                throw new Error(errorMessages.browserOffline);
            }
            const items = yield this.cacheStorage.all();
            const datetime = new Date().getTime();
            return Promise.all(items.filter((item) => item.expires < datetime).map((item) => this.removeItem(item.key)));
        });
    }
    /**
     * Removes all item with specified group
     * @param groupKey The group key
     * @returns A promise which resolves when all the items in the group have been cleared.
     */
    clearGroup(groupKey) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            const items = yield this.cacheStorage.all();
            return Promise.all(items.filter((item) => item.groupKey === groupKey).map((item) => this.removeItem(item.key)));
        });
    }
    /**
     * Creates the cache storage.
     * If it fails it will provide and error message.
     */
    loadCache() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                return;
            }
            try {
                yield this.cacheStorage.create();
            }
            catch (error) {
                this.cacheEnabled = false;
                console.error(errorMessages.initialization, error);
            }
        });
    }
    /**
     * Resets the storage back to being empty.
     */
    resetDatabase() {
        return __awaiter(this, void 0, void 0, function* () {
            const items = yield this.cacheStorage.all();
            return Promise.all(items.map((item) => this.removeItem(item.key)));
        });
    }
    /**
     * Saves a blob item to the cache storage with the provided options.
     * @param key The unique key
     * @param blob The blob to store
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns The saved data
     */
    saveBlobItem(key, blob, groupKey = 'none', ttl = this.ttl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.cacheEnabled) {
                throw new Error(errorMessages.notEnabled);
            }
            const expires = new Date().getTime() + ttl * 1000;
            const type = blob.type;
            try {
                const base64data = yield convertBlobToBase64(blob);
                const value = JSON.stringify(base64data);
                return this.cacheStorage.set(key, {
                    value,
                    expires,
                    type,
                    groupKey
                });
            }
            catch (error) {
                throw new Error(error);
            }
        });
    }
}
CacheService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheService, deps: [{ token: CacheStorageService }], target: i0.ɵɵFactoryTarget.Injectable });
CacheService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheService });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "12.1.4", ngImport: i0, type: CacheService, decorators: [{
            type: Injectable
        }], ctorParameters: function () { return [{ type: CacheStorageService }]; } });

/**
 * Generated bundle index. Do not edit.
 */

export { CONFIG, CacheModule, CacheService };
//# sourceMappingURL=ionic-cache.js.map
