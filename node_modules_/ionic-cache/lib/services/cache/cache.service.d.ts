import { Observable } from 'rxjs';
import { CacheStorageService } from '../cache-storage/cache-storage.service';
import { StorageCacheItem } from '../../interfaces/cache-storage-item.interface';
import * as i0 from "@angular/core";
export declare class CacheService {
    private cacheStorage;
    private ttl;
    private cacheEnabled;
    private invalidateOffline;
    constructor(cacheStorage: CacheStorageService);
    /**
     * Disable or enable cache.
     */
    enableCache(enable?: boolean): void;
    /**
     * Set if expired cache should be invalidated if device is offline.
     */
    setOfflineInvalidate(offlineInvalidate: boolean): void;
    /**
     * Set default TTL.
     * @param ttl TTL in seconds.
     */
    setDefaultTTL(ttl: number): number;
    /**
     * Checks if the device is online.
     */
    isOnline(): boolean;
    /**
     * Saves an item to the cache storage with the provided options.
     * @param key The unique key
     * @param data The data to store
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns The saved data
     */
    saveItem(key: string, data: any, groupKey?: string, ttl?: number): Promise<any>;
    /**
     * Deletes an item from the cache storage.
     * @param key The unique key
     * @returns A promise which will resolve when the item is removed.
     */
    removeItem(key: string): Promise<any>;
    /**
     * Removes all items with a key that matches pattern.
     * @returns A promise which will resolve when all the items are removed.
     */
    removeItems(pattern: string): Promise<any>;
    /**
     * Gets item from cache without checking if it is expired.
     * @param key The unique key
     * @returns A promise which will resolve with the data from the cache.
     */
    getRawItem(key: string): Promise<StorageCacheItem>;
    /**
     * Gets all items from the cache without checking if they are expired.
     * @returns A promise which will resove with all the items in the cache.
     */
    getRawItems(): Promise<StorageCacheItem[]>;
    /**
     * Check sif item exists in cache regardless if expired or not.
     * @param key The unique key
     * @returns A boolean which will be true the key if exists.
     */
    itemExists(key: string): Promise<boolean | string>;
    /**
     * Gets item from cache with expire check.
     * @param key The unique key
     * @returns The data from the cache
     */
    getItem<T = any>(key: string): Promise<T>;
    /**
     * Gets or sets an item in the cache storage
     * @param key The unique key
     * @param factory The factory to update the value with if it's not present.
     * @param groupKey The group key
     * @param ttl The TTL in seconds.
     * @returns A promise which resolves with the data.
     */
    getOrSetItem<T>(key: string, factory: () => Promise<T>, groupKey?: string, ttl?: number): Promise<T>;
    /**
     * Loads an item from the cache, if it's not there it will use the provided observable to set the value and return it.
     * @param key The unique key
     * @param observable The observable to provide the data if it's not present in the cache.
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns An observable with the data from the cache or provided observable.
     */
    loadFromObservable<T = any>(key: string, observable: any, groupKey?: string, ttl?: number): Observable<T>;
    /**
     * Loads an item from cache regardless of expiry.
     * If the delay type is set to expired it will only get data from the observable when the item is expired.
     * If the delay type is set to all it will always get data from the observable.
     * @param key The unique key
     * @param observable The observable with data.
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @param delayType The delay type, defaults to expired.
     * @param metaKey The property on T to which to assign meta data.
     * @returns An observable which will emit the data.
     */
    loadFromDelayedObservable<T = any>(key: string, observable: Observable<T>, groupKey?: string, ttl?: number, delayType?: string, metaKey?: string): Observable<T>;
    /**
     * Perform complete cache clear
     * @returns A promise which resolves when the cache storage is cleared.
     */
    clearAll(): Promise<any>;
    /**
     * Removes all expired items from the cache.
     * @param ignoreOnlineStatus Ignores the online status, defaults to false.
     * @returns A promise which resolves when all expired items are cleared from cache storage.
     */
    clearExpired(ignoreOnlineStatus?: boolean): Promise<any>;
    /**
     * Removes all item with specified group
     * @param groupKey The group key
     * @returns A promise which resolves when all the items in the group have been cleared.
     */
    clearGroup(groupKey: string): Promise<any>;
    /**
     * Creates the cache storage.
     * If it fails it will provide and error message.
     */
    private loadCache;
    /**
     * Resets the storage back to being empty.
     */
    private resetDatabase;
    /**
     * Saves a blob item to the cache storage with the provided options.
     * @param key The unique key
     * @param blob The blob to store
     * @param groupKey The group key
     * @param ttl The TTL in seconds
     * @returns The saved data
     */
    private saveBlobItem;
    static ɵfac: i0.ɵɵFactoryDeclaration<CacheService, never>;
    static ɵprov: i0.ɵɵInjectableDeclaration<CacheService>;
}
//# sourceMappingURL=cache.service.d.ts.map